# 开发指南

## 开发理念

### 核心信念

- **增量进步优于大爆炸** - 小步修改，确保每步都能编译并通过测试
- **从现有代码中学习** - 实施前先研究和规划
- **务实优于教条** - 根据项目实际情况调整
- **意图清晰优于代码巧妙** - 选择无聊但显而易见的方案

### 简单意味着

- 每个函数/类只负责单一职责
- 避免过早抽象
- 不玩花招 - 选择无聊的解决方案
- 如果需要解释，说明太复杂了

## 开发流程

### 1. 规划与分阶段

将复杂工作分解为 3-5 个阶段。在 `IMPLEMENTATION_PLAN.md` 中记录：

```markdown
## 阶段 N: [名称]

**目标**: [具体交付物]
**成功标准**: [可测试的结果]
**测试**: [具体测试用例]
**状态**: [未开始|进行中|已完成]
```

- 随着进展更新状态
- 所有阶段完成后删除文件

### 2. 实施流程

1. **理解** - 研究代码库中的现有模式
2. **测试** - 先写测试（红灯）
3. **实现** - 最小代码让测试通过（绿灯）
4. **重构** - 在测试通过的情况下清理代码
5. **提交** - 清晰的提交信息，关联到计划

### 3. 遇到困难时（尝试 3 次后）

**关键**: 每个问题最多尝试 3 次，然后必须停止。

1. **记录失败内容**：

   - 你尝试了什么
   - 具体的错误信息
   - 你认为失败的原因

2. **研究替代方案**：

   - 找到 2-3 个类似的实现
   - 记录不同的方法

3. **质疑基本假设**：

   - 这是正确的抽象层级吗？
   - 能分解成更小的问题吗？
   - 有更简单的方法吗？

4. **尝试不同角度**：
   - 不同的库/框架特性？
   - 不同的架构模式？
   - 移除抽象而不是添加？

## 技术标准

### 架构原则

- **组合优于继承** - 使用依赖注入
- **接口优于单例** - 实现可测试性和灵活性
- **显式优于隐式** - 清晰的数据流和依赖关系
- **尽可能测试驱动** - 永不禁用测试，而是修复它们

### 代码质量

- **每次提交必须**：

  - 成功编译
  - 通过所有现有测试
  - 为新功能包含测试
  - 遵循项目的格式化/检查规则

- **提交前**：
  - 运行格式化工具/代码检查
  - 自我审查修改
  - 确保提交信息解释"为什么"

### 错误处理

- 快速失败并提供描述性消息
- 包含调试所需的上下文
- 在适当的层级处理错误
- 永不静默吞掉异常

## 决策框架

当存在多种有效方法时，基于以下优先级选择：

1. **可测试性** - 我能轻松测试这个吗？
2. **可读性** - 6个月后还有人能理解吗？
3. **一致性** - 这符合项目模式吗？
4. **简单性** - 这是最简单的有效方案吗？
5. **可逆性** - 以后修改的难度如何？

## 项目集成

### 学习代码库

- 找到 3 个类似的功能/组件
- 识别常见模式和约定
- 尽可能使用相同的库/工具
- 遵循现有的测试模式

### 工具使用

- 使用项目现有的构建系统
- 使用项目的测试框架
- 使用项目的格式化/检查设置
- 没有充分理由不引入新工具

## 质量关卡

### 完成定义

- [ ] 测试已编写并通过
- [ ] 代码遵循项目约定
- [ ] 无代码检查/格式化警告
- [ ] 提交信息清晰
- [ ] 实现与计划匹配
- [ ] 没有不带 issue 编号的 TODO

### 测试指南

- 测试行为，而非实现
- 尽可能每个测试一个断言
- 清晰的测试名称描述场景
- 使用现有的测试工具/辅助函数
- 测试应该是确定性的

## 重要提醒

**永远不要**：

- 使用 `--no-verify` 绕过提交钩子
- 禁用测试而不修复它们
- 提交无法编译的代码
- 做假设 - 用现有代码验证

**始终要**：

- 增量提交可工作的代码
- 随时更新计划文档
- 从现有实现中学习
- 失败 3 次后停止并重新评估